## 说说php-fpm启动进程相关方面的设置？

针对php-fpm进程的管理，需要在php-fpm.conf配置文件中进行修改。进程运行的模式就只有动态(dynamic)和静态(static)。

1. 首先，我们关注一个前提设置： pm = static/dynamic,标识fpm子进程的产生模式。
2. static(静态) ：表示在fpm运行时直接fork出pm.max_chindren个worker进程。
3. dynamic(动态)：表示运行时fork出start_servers个进程，随着负载的情况，动态的调整，最多不超过max_children个进程。
> 一般推荐用static，优点是不用动态的判断负载情况，提升性能，缺点是多占用些系统内存资源。

max_children
1. 这个值原则上是越大越好，php-cgi的进程多了就会处理的很快，排队的请求就会很少。
2. 设置”max_children”也需要根据服务器的性能进行设定。
3. 一般来说一台服务器正常情况下每一个php-cgi所耗费的内存在20M左右。
4. 假设“max_children”设置成100个，20M*100=2000M。
5. 也就是说在峰值的时候所有PHP-CGI所耗内存在2000M以内。
6. 假设“max_children”设置的较小，比如5-10个，那么php-cgi就会“很累”，处理速度也很慢，等待的时间也较长。
7. 如果长时间没有得到处理的请求就会出现504 Gateway Time-out这个错误，而正在处理的很累的那几个php-cgi如果遇到了问题就会出现502 Bad gateway这个错误。

start_servers
1. pm.start_servers的默认值为2。并且php-fpm中给的计算方式也为：
> {（cpu空闲时等待连接的php的最小子进程数） + （cpu空闲时等待连接的php的最大子进程数 - cpu空闲时等待连接的php的最小子进程数）/ 2}；
用配置表示就是：min_spare_servers + (max_spare_servers - min_spare_servers) / 2；
一般而言，设置成10-20之间的数据足够满足需求了。

## 说说PHP的生命周期是怎么样的？以及每个阶段分别都做了什么操作？

php的运行模式有两种：web模式和cli模式。无论是哪种公众模式，php的工作原理都是一样的，都是作为一种SAPI运行。首先，认识下SAPI，它是什么。Sapi全称是Server Application Programming Interface，也就是服务端应用编程接口，Sapi通过一系列钩子函数，使得PHP可以和外围交互数据，这是PHP非常优雅和成功的一个设计，通过sapi成功的将PHP本身和上层应用解耦隔离，PHP可以不再考虑如何针对不同应用进行兼容，而应用本身也可以针对自己的特点实现不同的处理方式。
SAPI运行PHP都经过下面几个阶段:
1、模块初始化阶段（module init）
这个阶段主要进行php框架、zend引擎的初始化操作。这个阶段一般是在SAPI启动时执行一次，对于FPM而言，就是在fpm的master进行启动时执行的。php加载每个扩展的代码并调用其模块初始化例程（MINIT），进行一些模块所需变量的申请,内存分配等。

2、请求初始化阶段（request init）
当一个页面请求发生时，在请求处理前都会经历的一个阶段。对于fpm而言，是在worker进程accept一个请求并读取、解析完请求数据后的一个阶段。在这个阶段内，SAPI层将控制权交给PHP层，PHP初始化本次请求执行脚本所需的环境变量。比如接收客户端发送的post请求数据信息、http请求报文信息等。

3、php脚本执行阶段
php代码解析执行的过程。Zend引擎接管控制权，将php脚本代码编译成opcodes并顺次执行。这也我们的代码真正执行的阶段。

4、请求结束阶段（request shutdown）
请求处理完后就进入了结束阶段，PHP就会启动清理程序。这个阶段，将flush输出内容、发送http响应内容等，然后它会按顺序调用各个模块的RSHUTDOWN方法。 RSHUTDOWN用以清除程序运行时产生的符号表，也就是对每个变量调用unset函数。比如清除请求初始化阶段获取到的post请求参数、一些代码变量等。

5、模块关闭阶段（module shutdown）
该阶段在SAPI关闭时执行，与模块初始化阶段对应，这个阶段主要是进行资源的清理、php各模块的关闭操作，同时，将回调各扩展的module shutdown钩子函数。这是发生在所有请求都已经结束之后，例如关闭fpm的操作。（这个是对于CGI和CLI等SAPI，没有“下一个请求”，所以SAPI立刻开始关闭。）

## 说说fastcgi与cgi之间的区别是什么？

定义
CGI：通用网关接口协议（CGI）是一种对接`应用程序和网络服务器的接口协议`。CGI使外部程序与Web服务器之间交互成为可能。CGI程序运行在独立的进程中，并对每个Web请求创建一个进程，这种方法非常容易实现，但效率较差，难以扩展。
CGI程序运行在独立的进程中，并对`每个Web请求创建一个进程，在结束时销毁`。这种“每个请求一个新进程”的模型使得CGI程序非常容易实现，但效率较差，难以扩展。在高负载情况下，`进程创建和销毁进程的开销变得很大`。此外，由于地址空间无法共享，CGI进程模型限制了资源重用方法，如重用数据库连接、内存缓存等。

FastCGI：快速通用网关接口（Fast Common Gateway Interface／FastCGI）是一种让交互程序与Web服务器通信的协议。`FastCGI是早期通用网关接口（CGI）的增强版本。FastCGI致力于减少网页服务器与CGI程序之间交互的开销`，从而使服务器可以同时处理更多的网页请求。

区别
1. CGI每一次请求都会创建一个进程，在请求结束之后进程会销毁。每一个请求，都重复执行这样的逻辑。FastCGI与最大的区别在于，使用持续的进程来处理一连串的请求，不会在请求结束之后关闭进程，而是下一个请求来了之后继续使用。这些进程由FastCGI服务器管理，而不是web服务器。FastCGI具体的进程数量可以通过php-fpm.conf中的pm配置项进行操作。

2. 当进来一个请求时，web服务器把环境变量和这个页面请求通过一个socket比如FastCGI进程与web服务器（都位于本地）或者一个TCP 请求（FastCGI进程在远端的server farm）传递给FastCGI进程。
服务传入请求时，网络服务器通过Unix域套接字、命名管道或TCP连接向FastCGI进程发送环境变量信息和页面请求。响应通过相同的连接从进程返回到网络服务器，然后网络服务器将该响应传递给最终用户。连接可能在响应结束时关闭，但是web服务器和FastCGI服务进程都将持续，不会被销毁。

3. 每个单独的FastCGI进程在其生命周期内可以处理许多请求，从而避免了每个请求进程创建和终止的开销。并发处理多个请求可以通过几种方式来完成:通过内部多路复用使用一个连接(即一个连接上的多个请求)；通过使用多个连接；或者通过这些方法的混合。可以配置多个FastCGI服务器，提高稳定性和可扩展性。

## 能说一下PHP的垃圾回收机制是如何实现的吗？

## 能简单的描述一下Nginx与PHP通信的基本流程吗？

1. WebServer在启动时，载入FastCGI管理器。

2. FastCGI会完成初始化，启动多个CGI解释器。并等待客户端的连接 当客户端连接的时候，FastCGI管理器会连接其中的一个CGI解释器。webserver 将标准输入和cgi配置发送给cgi。

3. FastCGI将标准输出和错误输出返回给WebServer。当FastCGI关闭时，意味着本次请求完成。然后FastCGI等待着FastCGI管理器给他提供的下一次请求。

4. PHP请求过来的时候，NGINX会将请求发送给FastCGI的Master，发送给Worker。将编译后的结果发送个Nginx，然后返回给客户端。